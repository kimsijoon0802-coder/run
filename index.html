<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Neon Gemini Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #050011;
        font-family: 'Rajdhani', sans-serif;
        touch-action: none;
      }
      .font-cyber {
        font-family: 'Orbitron', sans-serif;
      }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react/": "https://aistudiocdn.com/react@^19.2.0/",
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "lucide-react": "https://aistudiocdn.com/lucide-react@^0.553.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
        "@react-three/postprocessing": "https://aistudiocdn.com/@react-three/postprocessing@^3.0.4",
        "@react-three/fiber": "https://aistudiocdn.com/@react-three/fiber@^9.4.0",
        "zustand": "https://aistudiocdn.com/zustand@^5.0.8",
        "uuid": "https://aistudiocdn.com/uuid@^13.0.0",
        "@react-three/drei": "https://aistudiocdn.com/@react-three/drei@^10.7.7",
        "three": "https://aistudiocdn.com/three@^0.181.1",
        "postprocessing": "https://aistudiocdn.com/postprocessing@^6.38.0"
      }
    }
    </script>
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef, useMemo, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame, useThree } from '@react-three/fiber';
      import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';
      import { BlendFunction } from 'postprocessing';
      import { Text3D, Center, Float } from '@react-three/drei';
      import { create } from 'zustand';
      import { v4 as uuidv4 } from 'uuid';
      import { Heart, Zap, Trophy, MapPin, Diamond, Rocket, ArrowUpCircle, Shield, Activity, PlusCircle, Play } from 'lucide-react';

      // --- TYPES ---
      const GameStatus = {
        MENU: 'MENU',
        PLAYING: 'PLAYING',
        SHOP: 'SHOP',
        GAME_OVER: 'GAME_OVER',
        VICTORY: 'VICTORY'
      };

      const ObjectType = {
        OBSTACLE: 'OBSTACLE',
        GEM: 'GEM',
        LETTER: 'LETTER',
        SHOP_PORTAL: 'SHOP_PORTAL',
        ALIEN: 'ALIEN',
        MISSILE: 'MISSILE'
      };

      const LANE_WIDTH = 2.2;
      const JUMP_HEIGHT = 2.5;
      const JUMP_DURATION = 0.6;
      const RUN_SPEED_BASE = 22.5;
      const SPAWN_DISTANCE = 120;
      const REMOVE_DISTANCE = 20;

      const GEMINI_COLORS = [
          '#2979ff', '#ff1744', '#ffea00', '#2979ff', '#00e676', '#ff1744'
      ];

      // --- AUDIO ---
      class AudioController {
        constructor() {
          this.ctx = null;
          this.masterGain = null;
        }

        init() {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.4;
            this.masterGain.connect(this.ctx.destination);
          }
          if (this.ctx.state === 'suspended') {
            this.ctx.resume().catch(() => {});
          }
        }

        playGemCollect() {
          if (!this.ctx || !this.masterGain) this.init();
          if (!this.ctx || !this.masterGain) return;

          const t = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();

          osc.type = 'sine';
          osc.frequency.setValueAtTime(1200, t);
          osc.frequency.exponentialRampToValueAtTime(2000, t + 0.1);

          gain.gain.setValueAtTime(0.5, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

          osc.connect(gain);
          gain.connect(this.masterGain);

          osc.start(t);
          osc.stop(t + 0.15);
        }

        playLetterCollect() {
          if (!this.ctx || !this.masterGain) this.init();
          if (!this.ctx || !this.masterGain) return;

          const t = this.ctx.currentTime;
          const freqs = [523.25, 659.25, 783.99]; 
          
          freqs.forEach((f, i) => {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = 'triangle';
              osc.frequency.value = f;
              const start = t + (i * 0.04);
              const dur = 0.3;
              gain.gain.setValueAtTime(0.3, start);
              gain.gain.exponentialRampToValueAtTime(0.01, start + dur);
              osc.connect(gain);
              gain.connect(this.masterGain);
              osc.start(start);
              osc.stop(start + dur);
          });
        }

        playJump(isDouble = false) {
          if (!this.ctx || !this.masterGain) this.init();
          if (!this.ctx || !this.masterGain) return;

          const t = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          const startFreq = isDouble ? 400 : 200;
          const endFreq = isDouble ? 800 : 450;
          osc.frequency.setValueAtTime(startFreq, t);
          osc.frequency.exponentialRampToValueAtTime(endFreq, t + 0.15);
          gain.gain.setValueAtTime(0.2, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
          osc.connect(gain);
          gain.connect(this.masterGain);
          osc.start(t);
          osc.stop(t + 0.15);
        }

        playDamage() {
          if (!this.ctx || !this.masterGain) this.init();
          if (!this.ctx || !this.masterGain) return;
          const t = this.ctx.currentTime;
          const bufferSize = this.ctx.sampleRate * 0.3;
          const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
              data[i] = Math.random() * 2 - 1;
          }
          const noise = this.ctx.createBufferSource();
          noise.buffer = buffer;
          const osc = this.ctx.createOscillator();
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(100, t);
          osc.frequency.exponentialRampToValueAtTime(20, t + 0.3);
          const oscGain = this.ctx.createGain();
          oscGain.gain.setValueAtTime(0.6, t);
          oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
          const noiseGain = this.ctx.createGain();
          noiseGain.gain.setValueAtTime(0.5, t);
          noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
          osc.connect(oscGain);
          oscGain.connect(this.masterGain);
          noise.connect(noiseGain);
          noiseGain.connect(this.masterGain);
          osc.start(t);
          osc.stop(t + 0.3);
          noise.start(t);
          noise.stop(t + 0.3);
        }
      }

      const audio = new AudioController();

      // --- STORE ---
      const GEMINI_TARGET = ['G', 'E', 'M', 'I', 'N', 'I'];
      const MAX_LEVEL = 3;

      const useStore = create((set, get) => ({
        status: GameStatus.MENU,
        score: 0,
        lives: 3,
        maxLives: 3,
        speed: 0,
        collectedLetters: [],
        level: 1,
        laneCount: 3,
        gemsCollected: 0,
        distance: 0,
        hasDoubleJump: false,
        hasImmortality: false,
        isImmortalityActive: false,

        startGame: () => set({ 
          status: GameStatus.PLAYING, 
          score: 0, 
          lives: 3, 
          maxLives: 3,
          speed: RUN_SPEED_BASE,
          collectedLetters: [],
          level: 1,
          laneCount: 3,
          gemsCollected: 0,
          distance: 0,
          hasDoubleJump: false,
          hasImmortality: false,
          isImmortalityActive: false
        }),

        restartGame: () => set({ 
          status: GameStatus.PLAYING, 
          score: 0, 
          lives: 3, 
          maxLives: 3,
          speed: RUN_SPEED_BASE,
          collectedLetters: [],
          level: 1,
          laneCount: 3,
          gemsCollected: 0,
          distance: 0,
          hasDoubleJump: false,
          hasImmortality: false,
          isImmortalityActive: false
        }),

        takeDamage: () => {
          const { lives, isImmortalityActive } = get();
          if (isImmortalityActive) return;
          if (lives > 1) {
            set({ lives: lives - 1 });
          } else {
            set({ lives: 0, status: GameStatus.GAME_OVER, speed: 0 });
          }
        },

        addScore: (amount) => set((state) => ({ score: state.score + amount })),
        
        collectGem: (value) => set((state) => ({ 
          score: state.score + value, 
          gemsCollected: state.gemsCollected + 1 
        })),

        setDistance: (dist) => set({ distance: dist }),

        collectLetter: (index) => {
          const { collectedLetters, level, speed } = get();
          if (!collectedLetters.includes(index)) {
            const newLetters = [...collectedLetters, index];
            const speedIncrease = RUN_SPEED_BASE * 0.10;
            const nextSpeed = speed + speedIncrease;
            set({ collectedLetters: newLetters, speed: nextSpeed });
            if (newLetters.length === GEMINI_TARGET.length) {
              if (level < MAX_LEVEL) {
                  get().advanceLevel();
              } else {
                  set({ status: GameStatus.VICTORY, score: get().score + 5000 });
              }
            }
          }
        },

        advanceLevel: () => {
            const { level, laneCount, speed } = get();
            const nextLevel = level + 1;
            const speedIncrease = RUN_SPEED_BASE * 0.40;
            const newSpeed = speed + speedIncrease;
            set({
                level: nextLevel,
                laneCount: Math.min(laneCount + 2, 9),
                status: GameStatus.PLAYING,
                speed: newSpeed,
                collectedLetters: []
            });
        },

        openShop: () => set({ status: GameStatus.SHOP }),
        closeShop: () => set({ status: GameStatus.PLAYING }),

        buyItem: (type, cost) => {
            const { score, maxLives, lives } = get();
            if (score >= cost) {
                set({ score: score - cost });
                switch (type) {
                    case 'DOUBLE_JUMP': set({ hasDoubleJump: true }); break;
                    case 'MAX_LIFE': set({ maxLives: maxLives + 1, lives: lives + 1 }); break;
                    case 'HEAL': set({ lives: Math.min(lives + 1, maxLives) }); break;
                    case 'IMMORTAL': set({ hasImmortality: true }); break;
                }
                return true;
            }
            return false;
        },

        activateImmortality: () => {
            const { hasImmortality, isImmortalityActive } = get();
            if (hasImmortality && !isImmortalityActive) {
                set({ isImmortalityActive: true });
                setTimeout(() => {
                    set({ isImmortalityActive: false });
                }, 5000);
            }
        },
        setStatus: (status) => set({ status }),
      }));

      // --- ENVIRONMENT ---
      const StarField = () => {
        const speed = useStore(state => state.speed);
        const count = 3000;
        const meshRef = useRef(null);
        const positions = useMemo(() => {
          const pos = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            let x = (Math.random() - 0.5) * 400;
            let y = (Math.random() - 0.5) * 200 + 50;
            let z = -550 + Math.random() * 650;
            if (Math.abs(x) < 15 && y > -5 && y < 20) {
                if (x < 0) x -= 15; else x += 15;
            }
            pos[i * 3] = x; pos[i * 3 + 1] = y; pos[i * 3 + 2] = z; 
          }
          return pos;
        }, []);

        useFrame((state, delta) => {
          if (!meshRef.current) return;
          const positions = meshRef.current.geometry.attributes.position.array;
          const activeSpeed = speed > 0 ? speed : 2;
          for (let i = 0; i < count; i++) {
              let z = positions[i * 3 + 2];
              z += activeSpeed * delta * 2.0;
              if (z > 100) {
                  z = -550 - Math.random() * 50;
                  let x = (Math.random() - 0.5) * 400;
                  let y = (Math.random() - 0.5) * 200 + 50;
                  if (Math.abs(x) < 15 && y > -5 && y < 20) {
                      if (x < 0) x -= 15; else x += 15;
                  }
                  positions[i * 3] = x; positions[i * 3 + 1] = y;
              }
              positions[i * 3 + 2] = z;
          }
          meshRef.current.geometry.attributes.position.needsUpdate = true;
        });

        return (
          <points ref={meshRef}>
            <bufferGeometry>
              <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
            </bufferGeometry>
            <pointsMaterial size={0.5} color="#ffffff" transparent opacity={0.8} sizeAttenuation />
          </points>
        );
      };

      const LaneGuides = () => {
          const { laneCount } = useStore();
          const separators = useMemo(() => {
              const lines = [];
              const startX = -(laneCount * LANE_WIDTH) / 2;
              for (let i = 0; i <= laneCount; i++) lines.push(startX + (i * LANE_WIDTH));
              return lines;
          }, [laneCount]);

          return (
              <group position={[0, 0.02, 0]}>
                  <mesh position={[0, -0.02, -20]} rotation={[-Math.PI / 2, 0, 0]}>
                      <planeGeometry args={[laneCount * LANE_WIDTH, 200]} />
                      <meshBasicMaterial color="#1a0b2e" transparent opacity={0.9} />
                  </mesh>
                  {separators.map((x, i) => (
                      <mesh key={`sep-${i}`} position={[x, 0, -20]} rotation={[-Math.PI / 2, 0, 0]}>
                          <planeGeometry args={[0.05, 200]} /> 
                          <meshBasicMaterial color="#00ffff" transparent opacity={0.4} />
                      </mesh>
                  ))}
              </group>
          );
      };

      const RetroSun = () => {
          const matRef = useRef(null);
          const sunGroupRef = useRef(null);
          useFrame((state) => {
              if (matRef.current) matRef.current.uniforms.uTime.value = state.clock.elapsedTime;
              if (sunGroupRef.current) {
                  sunGroupRef.current.position.y = 30 + Math.sin(state.clock.elapsedTime * 0.2) * 1.0;
                  sunGroupRef.current.rotation.y = state.clock.elapsedTime * 0.05;
              }
          });
          const uniforms = useMemo(() => ({
              uTime: { value: 0 },
              uColorTop: { value: new THREE.Color('#ffe600') },
              uColorBottom: { value: new THREE.Color('#ff0077') }
          }), []);

          return (
              <group ref={sunGroupRef} position={[0, 30, -180]}>
                  <mesh>
                      <sphereGeometry args={[35, 32, 32]} />
                      <shaderMaterial
                          ref={matRef}
                          uniforms={uniforms}
                          transparent
                          vertexShader={`
                              varying vec2 vUv;
                              void main() {
                                  vUv = uv;
                                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                              }
                          `}
                          fragmentShader={`
                              varying vec2 vUv;
                              uniform float uTime;
                              uniform vec3 uColorTop;
                              uniform vec3 uColorBottom;
                              void main() {
                                  vec3 color = mix(uColorBottom, uColorTop, vUv.y);
                                  float stripeFreq = 40.0;
                                  float stripeSpeed = 1.0;
                                  float stripes = sin((vUv.y * stripeFreq) - (uTime * stripeSpeed));
                                  float stripeMask = smoothstep(0.2, 0.3, stripes);
                                  float scanlineFade = smoothstep(0.7, 0.3, vUv.y); 
                                  vec3 finalColor = mix(color, color * 0.1, (1.0 - stripeMask) * scanlineFade);
                                  gl_FragColor = vec4(finalColor, 1.0);
                              }
                          `}
                      />
                  </mesh>
              </group>
          );
      };

      const MovingGrid = () => {
          const speed = useStore(state => state.speed);
          const meshRef = useRef(null);
          const offsetRef = useRef(0);
          useFrame((state, delta) => {
              if (meshRef.current) {
                   const activeSpeed = speed > 0 ? speed : 5;
                   offsetRef.current += activeSpeed * delta;
                   const cellSize = 10;
                   const zPos = -100 + (offsetRef.current % cellSize);
                   meshRef.current.position.z = zPos;
              }
          });
          return (
              <mesh ref={meshRef} rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.2, -100]}>
                  <planeGeometry args={[300, 400, 30, 40]} />
                  <meshBasicMaterial color="#8800ff" wireframe transparent opacity={0.15} />
              </mesh>
          );
      };

      const Environment = () => {
        return (
          <>
            <color attach="background" args={['#050011']} />
            <fog attach="fog" args={['#050011', 40, 160]} />
            <ambientLight intensity={0.2} color="#400080" />
            <directionalLight position={[0, 20, -10]} intensity={1.5} color="#00ffff" />
            <pointLight position={[0, 25, -150]} intensity={2} color="#ff00aa" distance={200} decay={2} />
            <StarField />
            <MovingGrid />
            <LaneGuides />
            <RetroSun />
          </>
        );
      };

      // --- EFFECTS ---
      const Effects = () => {
        return (
          <EffectComposer disableNormalPass multisampling={0}>
            <Bloom luminanceThreshold={0.75} mipmapBlur intensity={1.0} radius={0.6} levels={8} />
            <Noise opacity={0.05} blendFunction={BlendFunction.OVERLAY} />
            <Vignette eskil={false} offset={0.1} darkness={0.5} />
          </EffectComposer>
        );
      };

      // --- PLAYER ---
      const TORSO_GEO = new THREE.CylinderGeometry(0.25, 0.15, 0.6, 4);
      const JETPACK_GEO = new THREE.BoxGeometry(0.3, 0.4, 0.15);
      const GLOW_STRIP_GEO = new THREE.PlaneGeometry(0.05, 0.2);
      const HEAD_GEO = new THREE.BoxGeometry(0.25, 0.3, 0.3);
      const ARM_GEO = new THREE.BoxGeometry(0.12, 0.6, 0.12);
      const JOINT_SPHERE_GEO = new THREE.SphereGeometry(0.07);
      const HIPS_GEO = new THREE.CylinderGeometry(0.16, 0.16, 0.2);
      const LEG_GEO = new THREE.BoxGeometry(0.15, 0.7, 0.15);
      const SHADOW_GEO = new THREE.CircleGeometry(0.5, 32);
      const GRAVITY = 50;
      const JUMP_FORCE = 16;

      const Player = () => {
        const groupRef = useRef(null);
        const bodyRef = useRef(null);
        const shadowRef = useRef(null);
        const leftArmRef = useRef(null);
        const rightArmRef = useRef(null);
        const leftLegRef = useRef(null);
        const rightLegRef = useRef(null);
        const headRef = useRef(null);
        const { status, laneCount, takeDamage, hasDoubleJump, activateImmortality, isImmortalityActive } = useStore();
        const [lane, setLane] = useState(0);
        const targetX = useRef(0);
        const isJumping = useRef(false);
        const velocityY = useRef(0);
        const jumpsPerformed = useRef(0); 
        const spinRotation = useRef(0);
        const touchStartX = useRef(0);
        const touchStartY = useRef(0);
        const isInvincible = useRef(false);
        const lastDamageTime = useRef(0);

        const { armorMaterial, jointMaterial, glowMaterial, shadowMaterial } = useMemo(() => {
            const armorColor = isImmortalityActive ? '#ffd700' : '#00aaff';
            const glowColor = isImmortalityActive ? '#ffffff' : '#00ffff';
            return {
                armorMaterial: new THREE.MeshStandardMaterial({ color: armorColor, roughness: 0.3, metalness: 0.8 }),
                jointMaterial: new THREE.MeshStandardMaterial({ color: '#111111', roughness: 0.7, metalness: 0.5 }),
                glowMaterial: new THREE.MeshBasicMaterial({ color: glowColor }),
                shadowMaterial: new THREE.MeshBasicMaterial({ color: '#000000', opacity: 0.3, transparent: true })
            };
        }, [isImmortalityActive]);

        useEffect(() => {
            if (status === GameStatus.PLAYING) {
                isJumping.current = false;
                jumpsPerformed.current = 0;
                velocityY.current = 0;
                spinRotation.current = 0;
                if (groupRef.current) groupRef.current.position.y = 0;
                if (bodyRef.current) bodyRef.current.rotation.x = 0;
            }
        }, [status]);
        
        useEffect(() => {
            const maxLane = Math.floor(laneCount / 2);
            if (Math.abs(lane) > maxLane) {
                setLane(l => Math.max(Math.min(l, maxLane), -maxLane));
            }
        }, [laneCount, lane]);

        const triggerJump = () => {
          const maxJumps = hasDoubleJump ? 2 : 1;
          if (!isJumping.current) {
              audio.playJump(false);
              isJumping.current = true;
              jumpsPerformed.current = 1;
              velocityY.current = JUMP_FORCE;
          } else if (jumpsPerformed.current < maxJumps) {
              audio.playJump(true);
              jumpsPerformed.current += 1;
              velocityY.current = JUMP_FORCE;
              spinRotation.current = 0;
          }
        };

        useEffect(() => {
          const handleKeyDown = (e) => {
            if (status !== GameStatus.PLAYING) return;
            const maxLane = Math.floor(laneCount / 2);
            if (e.key === 'ArrowLeft') setLane(l => Math.max(l - 1, -maxLane));
            else if (e.key === 'ArrowRight') setLane(l => Math.min(l + 1, maxLane));
            else if (e.key === 'ArrowUp' || e.key === 'w') triggerJump();
            else if (e.key === ' ' || e.key === 'Enter') activateImmortality();
          };
          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [status, laneCount, hasDoubleJump, activateImmortality]);

        useEffect(() => {
          const handleTouchStart = (e) => {
            touchStartX.current = e.touches[0].clientX;
            touchStartY.current = e.touches[0].clientY;
          };
          const handleTouchEnd = (e) => {
              if (status !== GameStatus.PLAYING) return;
              const deltaX = e.changedTouches[0].clientX - touchStartX.current;
              const deltaY = e.changedTouches[0].clientY - touchStartY.current;
              const maxLane = Math.floor(laneCount / 2);
              if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                   if (deltaX > 0) setLane(l => Math.min(l + 1, maxLane));
                   else setLane(l => Math.max(l - 1, -maxLane));
              } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < -30) {
                  triggerJump();
              } else if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
                  activateImmortality();
              }
          };
          window.addEventListener('touchstart', handleTouchStart);
          window.addEventListener('touchend', handleTouchEnd);
          return () => {
              window.removeEventListener('touchstart', handleTouchStart);
              window.removeEventListener('touchend', handleTouchEnd);
          };
        }, [status, laneCount, hasDoubleJump, activateImmortality]);

        useFrame((state, delta) => {
          if (!groupRef.current) return;
          if (status !== GameStatus.PLAYING && status !== GameStatus.SHOP) return;

          targetX.current = lane * LANE_WIDTH;
          groupRef.current.position.x = THREE.MathUtils.lerp(groupRef.current.position.x, targetX.current, delta * 15);

          if (isJumping.current) {
              groupRef.current.position.y += velocityY.current * delta;
              velocityY.current -= GRAVITY * delta;
              if (groupRef.current.position.y <= 0) {
                  groupRef.current.position.y = 0;
                  isJumping.current = false;
                  jumpsPerformed.current = 0;
                  velocityY.current = 0;
                  if (bodyRef.current) bodyRef.current.rotation.x = 0;
              }
              if (jumpsPerformed.current === 2 && bodyRef.current) {
                   spinRotation.current -= delta * 15;
                   if (spinRotation.current < -Math.PI * 2) spinRotation.current = -Math.PI * 2;
                   bodyRef.current.rotation.x = spinRotation.current;
              }
          }

          const xDiff = targetX.current - groupRef.current.position.x;
          groupRef.current.rotation.z = -xDiff * 0.2; 
          groupRef.current.rotation.x = isJumping.current ? 0.1 : 0.05; 

          const time = state.clock.elapsedTime * 25; 
          
          if (!isJumping.current) {
              if (leftArmRef.current) leftArmRef.current.rotation.x = Math.sin(time) * 0.7;
              if (rightArmRef.current) rightArmRef.current.rotation.x = Math.sin(time + Math.PI) * 0.7;
              if (leftLegRef.current) leftLegRef.current.rotation.x = Math.sin(time + Math.PI) * 1.0;
              if (rightLegRef.current) rightLegRef.current.rotation.x = Math.sin(time) * 1.0;
              if (bodyRef.current) bodyRef.current.position.y = 1.1 + Math.abs(Math.sin(time)) * 0.1;
          } else {
              const jumpPoseSpeed = delta * 10;
              if (leftArmRef.current) leftArmRef.current.rotation.x = THREE.MathUtils.lerp(leftArmRef.current.rotation.x, -2.5, jumpPoseSpeed);
              if (rightArmRef.current) rightArmRef.current.rotation.x = THREE.MathUtils.lerp(rightArmRef.current.rotation.x, -2.5, jumpPoseSpeed);
              if (leftLegRef.current) leftLegRef.current.rotation.x = THREE.MathUtils.lerp(leftLegRef.current.rotation.x, 0.5, jumpPoseSpeed);
              if (rightLegRef.current) rightLegRef.current.rotation.x = THREE.MathUtils.lerp(rightLegRef.current.rotation.x, -0.5, jumpPoseSpeed);
              if (bodyRef.current && jumpsPerformed.current !== 2) bodyRef.current.position.y = 1.1; 
          }

          if (shadowRef.current) {
              const height = groupRef.current.position.y;
              const scale = Math.max(0.2, 1 - (height / 2.5) * 0.5);
              const runStretch = isJumping.current ? 1 : 1 + Math.abs(Math.sin(time)) * 0.3;
              shadowRef.current.scale.set(scale, scale, scale * runStretch);
              shadowRef.current.material.opacity = Math.max(0.1, 0.3 - (height / 2.5) * 0.2);
          }

          const showFlicker = isInvincible.current || isImmortalityActive;
          if (showFlicker) {
              if (isInvincible.current) {
                   if (Date.now() - lastDamageTime.current > 1500) {
                      isInvincible.current = false;
                      groupRef.current.visible = true;
                   } else {
                      groupRef.current.visible = Math.floor(Date.now() / 50) % 2 === 0;
                   }
              } 
              if (isImmortalityActive) groupRef.current.visible = true; 
          } else {
              groupRef.current.visible = true;
          }
        });

        useEffect(() => {
           const checkHit = (e) => {
              if (isInvincible.current || isImmortalityActive) return;
              audio.playDamage();
              takeDamage();
              isInvincible.current = true;
              lastDamageTime.current = Date.now();
           };
           window.addEventListener('player-hit', checkHit);
           return () => window.removeEventListener('player-hit', checkHit);
        }, [takeDamage, isImmortalityActive]);

        return (
          <group ref={groupRef} position={[0, 0, 0]}>
            <group ref={bodyRef} position={[0, 1.1, 0]}> 
              <mesh castShadow position={[0, 0.2, 0]} geometry={TORSO_GEO} material={armorMaterial} />
              <mesh position={[0, 0.2, -0.2]} geometry={JETPACK_GEO} material={jointMaterial} />
              <mesh position={[-0.08, 0.1, -0.28]} geometry={GLOW_STRIP_GEO} material={glowMaterial} />
              <mesh position={[0.08, 0.1, -0.28]} geometry={GLOW_STRIP_GEO} material={glowMaterial} />
              <group ref={headRef} position={[0, 0.6, 0]}>
                  <mesh castShadow geometry={HEAD_GEO} material={armorMaterial} />
              </group>
              <group position={[0.32, 0.4, 0]}>
                  <group ref={rightArmRef}>
                      <mesh position={[0, -0.25, 0]} castShadow geometry={ARM_GEO} material={armorMaterial} />
                      <mesh position={[0, -0.55, 0]} geometry={JOINT_SPHERE_GEO} material={glowMaterial} />
                  </group>
              </group>
              <group position={[-0.32, 0.4, 0]}>
                  <group ref={leftArmRef}>
                       <mesh position={[0, -0.25, 0]} castShadow geometry={ARM_GEO} material={armorMaterial} />
                       <mesh position={[0, -0.55, 0]} geometry={JOINT_SPHERE_GEO} material={glowMaterial} />
                  </group>
              </group>
              <mesh position={[0, -0.15, 0]} geometry={HIPS_GEO} material={jointMaterial} />
              <group position={[0.12, -0.25, 0]}>
                  <group ref={rightLegRef}>
                       <mesh position={[0, -0.35, 0]} castShadow geometry={LEG_GEO} material={armorMaterial} />
                  </group>
              </group>
              <group position={[-0.12, -0.25, 0]}>
                  <group ref={leftLegRef}>
                       <mesh position={[0, -0.35, 0]} castShadow geometry={LEG_GEO} material={armorMaterial} />
                  </group>
              </group>
            </group>
            <mesh ref={shadowRef} position={[0, 0.02, 0]} rotation={[-Math.PI/2, 0, 0]} geometry={SHADOW_GEO} material={shadowMaterial} />
          </group>
        );
      };

      // --- LEVEL MANAGER ---
      const OBSTACLE_HEIGHT = 1.6;
      const OBSTACLE_GEOMETRY = new THREE.ConeGeometry(0.9, OBSTACLE_HEIGHT, 6);
      const OBSTACLE_GLOW_GEO = new THREE.ConeGeometry(0.9, OBSTACLE_HEIGHT, 6);
      const OBSTACLE_RING_GEO = new THREE.RingGeometry(0.6, 0.9, 6);
      const GEM_GEOMETRY = new THREE.IcosahedronGeometry(0.3, 0);
      const ALIEN_BODY_GEO = new THREE.CylinderGeometry(0.6, 0.3, 0.3, 8);
      const ALIEN_DOME_GEO = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI/2);
      const ALIEN_EYE_GEO = new THREE.SphereGeometry(0.1);
      const MISSILE_CORE_GEO = new THREE.CylinderGeometry(0.08, 0.08, 3.0, 8);
      const MISSILE_RING_GEO = new THREE.TorusGeometry(0.15, 0.02, 16, 32);
      const SHADOW_LETTER_GEO = new THREE.PlaneGeometry(2, 0.6);
      const SHADOW_GEM_GEO = new THREE.CircleGeometry(0.6, 32);
      const SHADOW_ALIEN_GEO = new THREE.CircleGeometry(0.8, 32);
      const SHADOW_MISSILE_GEO = new THREE.PlaneGeometry(0.15, 3);
      const SHADOW_DEFAULT_GEO = new THREE.CircleGeometry(0.8, 6);
      const SHOP_FRAME_GEO = new THREE.BoxGeometry(1, 7, 1);
      const SHOP_BACK_GEO = new THREE.BoxGeometry(1, 5, 1.2);
      const SHOP_OUTLINE_GEO = new THREE.BoxGeometry(1, 7.2, 0.8);
      const SHOP_FLOOR_GEO = new THREE.PlaneGeometry(1, 4);
      const PARTICLE_COUNT = 600;
      const BASE_LETTER_INTERVAL = 150; 
      const MISSILE_SPEED = 30;
      const FONT_URL = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_bold.typeface.json";

      const getLetterInterval = (level) => BASE_LETTER_INTERVAL * Math.pow(1.5, Math.max(0, level - 1));

      const ParticleSystem = () => {
          const mesh = useRef(null);
          const dummy = useMemo(() => new THREE.Object3D(), []);
          const particles = useMemo(() => new Array(PARTICLE_COUNT).fill(0).map(() => ({
              life: 0, pos: new THREE.Vector3(), vel: new THREE.Vector3(), rot: new THREE.Vector3(), rotVel: new THREE.Vector3(), color: new THREE.Color()
          })), []);

          useEffect(() => {
              const handleExplosion = (e) => {
                  const { position, color } = e.detail;
                  let spawned = 0;
                  const burstAmount = 40; 
                  for(let i = 0; i < PARTICLE_COUNT; i++) {
                      const p = particles[i];
                      if (p.life <= 0) {
                          p.life = 1.0 + Math.random() * 0.5; 
                          p.pos.set(position[0], position[1], position[2]);
                          const theta = Math.random() * Math.PI * 2;
                          const phi = Math.acos(2 * Math.random() - 1);
                          const speed = 2 + Math.random() * 10;
                          p.vel.set(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi)).multiplyScalar(speed);
                          p.rot.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                          p.rotVel.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(5);
                          p.color.set(color);
                          spawned++;
                          if (spawned >= burstAmount) break;
                      }
                  }
              };
              window.addEventListener('particle-burst', handleExplosion);
              return () => window.removeEventListener('particle-burst', handleExplosion);
          }, [particles]);

          useFrame((state, delta) => {
              if (!mesh.current) return;
              const safeDelta = Math.min(delta, 0.1);
              particles.forEach((p, i) => {
                  if (p.life > 0) {
                      p.life -= safeDelta * 1.5;
                      p.pos.addScaledVector(p.vel, safeDelta);
                      p.vel.y -= safeDelta * 5; 
                      p.vel.multiplyScalar(0.98);
                      p.rot.x += p.rotVel.x * safeDelta;
                      p.rot.y += p.rotVel.y * safeDelta;
                      dummy.position.copy(p.pos);
                      const scale = Math.max(0, p.life * 0.25);
                      dummy.scale.set(scale, scale, scale);
                      dummy.rotation.set(p.rot.x, p.rot.y, p.rot.z);
                      dummy.updateMatrix();
                      mesh.current.setMatrixAt(i, dummy.matrix);
                      mesh.current.setColorAt(i, p.color);
                  } else {
                      dummy.scale.set(0,0,0);
                      dummy.updateMatrix();
                      mesh.current.setMatrixAt(i, dummy.matrix);
                  }
              });
              mesh.current.instanceMatrix.needsUpdate = true;
              if (mesh.current.instanceColor) mesh.current.instanceColor.needsUpdate = true;
          });

          return (
              <instancedMesh ref={mesh} args={[undefined, undefined, PARTICLE_COUNT]}>
                  <octahedronGeometry args={[0.5, 0]} />
                  <meshBasicMaterial toneMapped={false} transparent opacity={0.9} />
              </instancedMesh>
          );
      };

      const GameEntity = React.memo(({ data }) => {
        const groupRef = useRef(null);
        const visualRef = useRef(null);
        const shadowRef = useRef(null);
        const { laneCount } = useStore();
        
        useFrame((state, delta) => {
            if (groupRef.current) groupRef.current.position.set(data.position[0], 0, data.position[2]);
            if (visualRef.current) {
                const baseHeight = data.position[1];
                if (data.type === ObjectType.SHOP_PORTAL) {
                     visualRef.current.scale.setScalar(1 + Math.sin(state.clock.elapsedTime * 2) * 0.02);
                } else if (data.type === ObjectType.MISSILE) {
                     visualRef.current.rotation.z += delta * 20;
                     visualRef.current.position.y = baseHeight;
                } else if (data.type === ObjectType.ALIEN) {
                     visualRef.current.position.y = baseHeight + Math.sin(state.clock.elapsedTime * 3) * 0.2;
                     visualRef.current.rotation.y += delta;
                } else if (data.type !== ObjectType.OBSTACLE) {
                    visualRef.current.rotation.y += delta * 3;
                    const bobOffset = Math.sin(state.clock.elapsedTime * 4 + data.position[0]) * 0.1;
                    visualRef.current.position.y = baseHeight + bobOffset;
                    if (shadowRef.current) {
                        const shadowScale = 1 - bobOffset; 
                        shadowRef.current.scale.setScalar(shadowScale);
                    }
                } else {
                    visualRef.current.position.y = baseHeight;
                }
            }
        });

        const shadowGeo = useMemo(() => {
            if (data.type === ObjectType.LETTER) return SHADOW_LETTER_GEO;
            if (data.type === ObjectType.GEM) return SHADOW_GEM_GEO;
            if (data.type === ObjectType.SHOP_PORTAL) return null;
            if (data.type === ObjectType.ALIEN) return SHADOW_ALIEN_GEO;
            if (data.type === ObjectType.MISSILE) return SHADOW_MISSILE_GEO;
            return SHADOW_DEFAULT_GEO; 
        }, [data.type]);

        return (
            <group ref={groupRef} position={[data.position[0], 0, data.position[2]]}>
                {data.type !== ObjectType.SHOP_PORTAL && shadowGeo && (
                    <mesh ref={shadowRef} rotation={[-Math.PI / 2, 0, 0]} position={[0, 0.03, 0]} geometry={shadowGeo}>
                        <meshBasicMaterial color="#000000" opacity={0.3} transparent />
                    </mesh>
                )}

                <group ref={visualRef} position={[0, data.position[1], 0]}>
                    {data.type === ObjectType.SHOP_PORTAL && (
                        <group>
                             <mesh position={[0, 3, 0]} geometry={SHOP_FRAME_GEO} scale={[laneCount * LANE_WIDTH + 2, 1, 1]}>
                                 <meshStandardMaterial color="#111111" metalness={0.8} roughness={0.2} />
                             </mesh>
                             <mesh position={[0, 2, 0]} geometry={SHOP_BACK_GEO} scale={[laneCount * LANE_WIDTH, 1, 1]}>
                                  <meshBasicMaterial color="#000000" />
                             </mesh>
                             <mesh position={[0, 3, 0]} geometry={SHOP_OUTLINE_GEO} scale={[laneCount * LANE_WIDTH + 2.2, 1, 1]}>
                                 <meshBasicMaterial color="#00ffff" wireframe transparent opacity={0.3} />
                             </mesh>
                             <Center position={[0, 5, 0.6]}>
                                 <Text3D font={FONT_URL} size={1.2} height={0.2}>
                                     CYBER SHOP
                                     <meshBasicMaterial color="#ffff00" />
                                 </Text3D>
                             </Center>
                             <mesh position={[0, 0.1, 0]} rotation={[-Math.PI/2, 0, 0]} geometry={SHOP_FLOOR_GEO} scale={[laneCount * LANE_WIDTH, 1, 1]}>
                                 <meshBasicMaterial color="#00ffff" transparent opacity={0.3} />
                             </mesh>
                        </group>
                    )}
                    {data.type === ObjectType.OBSTACLE && (
                        <group>
                            <mesh geometry={OBSTACLE_GEOMETRY} castShadow receiveShadow>
                                 <meshStandardMaterial color="#330011" roughness={0.3} metalness={0.8} flatShading={true} />
                            </mesh>
                            <mesh scale={[1.02, 1.02, 1.02]} geometry={OBSTACLE_GLOW_GEO}>
                                 <meshBasicMaterial color={data.color} wireframe transparent opacity={0.3} />
                            </mesh>
                             <mesh position={[0, -OBSTACLE_HEIGHT/2 + 0.05, 0]} rotation={[-Math.PI/2,0,0]} geometry={OBSTACLE_RING_GEO}>
                                 <meshBasicMaterial color={data.color} transparent opacity={0.4} side={THREE.DoubleSide} />
                             </mesh>
                        </group>
                    )}
                    {data.type === ObjectType.ALIEN && (
                        <group>
                            <mesh castShadow geometry={ALIEN_BODY_GEO}>
                                <meshStandardMaterial color="#4400cc" metalness={0.8} roughness={0.2} />
                            </mesh>
                            <mesh position={[0, 0.2, 0]} geometry={ALIEN_DOME_GEO}>
                                <meshStandardMaterial color="#00ff00" emissive="#00ff00" emissiveIntensity={0.5} transparent opacity={0.8} />
                            </mesh>
                            <mesh position={[0.3, 0, 0.3]} geometry={ALIEN_EYE_GEO}><meshBasicMaterial color="#ff00ff" /></mesh>
                            <mesh position={[-0.3, 0, 0.3]} geometry={ALIEN_EYE_GEO}><meshBasicMaterial color="#ff00ff" /></mesh>
                        </group>
                    )}
                    {data.type === ObjectType.MISSILE && (
                        <group rotation={[Math.PI / 2, 0, 0]}>
                            <mesh geometry={MISSILE_CORE_GEO}><meshStandardMaterial color="#ff0000" emissive="#ff0000" emissiveIntensity={4} /></mesh>
                            <mesh position={[0, 1.0, 0]} geometry={MISSILE_RING_GEO}><meshBasicMaterial color="#ffff00" /></mesh>
                            <mesh position={[0, 0, 0]} geometry={MISSILE_RING_GEO}><meshBasicMaterial color="#ffff00" /></mesh>
                            <mesh position={[0, -1.0, 0]} geometry={MISSILE_RING_GEO}><meshBasicMaterial color="#ffff00" /></mesh>
                        </group>
                    )}
                    {data.type === ObjectType.GEM && (
                        <mesh castShadow geometry={GEM_GEOMETRY}>
                            <meshStandardMaterial color={data.color} roughness={0} metalness={1} emissive={data.color} emissiveIntensity={2} />
                        </mesh>
                    )}
                    {data.type === ObjectType.LETTER && (
                        <group scale={[1.5, 1.5, 1.5]}>
                             <Center>
                                 <Text3D font={FONT_URL} size={0.8} height={0.5} bevelEnabled bevelThickness={0.02} bevelSize={0.02} bevelSegments={5}>
                                    {data.value}
                                    <meshStandardMaterial color={data.color} emissive={data.color} emissiveIntensity={1.5} />
                                 </Text3D>
                             </Center>
                        </group>
                    )}
                </group>
            </group>
        );
      });

      const getRandomLane = (laneCount) => {
          const max = Math.floor(laneCount / 2);
          return Math.floor(Math.random() * (max * 2 + 1)) - max;
      };

      const LevelManager = () => {
        const { status, speed, collectGem, collectLetter, collectedLetters, laneCount, setDistance, openShop, level } = useStore();
        const objectsRef = useRef([]);
        const [renderTrigger, setRenderTrigger] = useState(0);
        const prevStatus = useRef(status);
        const prevLevel = useRef(level);
        const playerObjRef = useRef(null);
        const distanceTraveled = useRef(0);
        const nextLetterDistance = useRef(BASE_LETTER_INTERVAL);

        useEffect(() => {
          const isRestart = status === GameStatus.PLAYING && prevStatus.current === GameStatus.GAME_OVER;
          const isMenuReset = status === GameStatus.MENU;
          const isLevelUp = level !== prevLevel.current && status === GameStatus.PLAYING;
          const isVictoryReset = status === GameStatus.PLAYING && prevStatus.current === GameStatus.VICTORY;

          if (isMenuReset || isRestart || isVictoryReset) {
              objectsRef.current = [];
              setRenderTrigger(t => t + 1);
              distanceTraveled.current = 0;
              nextLetterDistance.current = getLetterInterval(1);
          } else if (isLevelUp && level > 1) {
              objectsRef.current = objectsRef.current.filter(obj => obj.position[2] > -80);
              objectsRef.current.push({ id: uuidv4(), type: ObjectType.SHOP_PORTAL, position: [0, 0, -100], active: true });
              nextLetterDistance.current = distanceTraveled.current - SPAWN_DISTANCE + getLetterInterval(level);
              setRenderTrigger(t => t + 1);
          } else if (status === GameStatus.GAME_OVER || status === GameStatus.VICTORY) {
              setDistance(Math.floor(distanceTraveled.current));
          }
          prevStatus.current = status;
          prevLevel.current = level;
        }, [status, level, setDistance]);

        useFrame((state) => {
            if (!playerObjRef.current) {
                const group = state.scene.getObjectByName('PlayerGroup');
                if (group && group.children.length > 0) playerObjRef.current = group.children[0];
            }
        });

        useFrame((state, delta) => {
          if (status !== GameStatus.PLAYING) return;
          const safeDelta = Math.min(delta, 0.05); 
          const dist = speed * safeDelta;
          distanceTraveled.current += dist;
          let hasChanges = false;
          let playerPos = new THREE.Vector3(0, 0, 0);
          if (playerObjRef.current) playerObjRef.current.getWorldPosition(playerPos);

          const currentObjects = objectsRef.current;
          const keptObjects = [];
          const newSpawns = [];

          for (const obj of currentObjects) {
              let moveAmount = dist;
              if (obj.type === ObjectType.MISSILE) moveAmount += MISSILE_SPEED * safeDelta;
              const prevZ = obj.position[2];
              obj.position[2] += moveAmount;
              
              if (obj.type === ObjectType.ALIEN && obj.active && !obj.hasFired) {
                   if (obj.position[2] > -90) {
                       obj.hasFired = true;
                       newSpawns.push({ id: uuidv4(), type: ObjectType.MISSILE, position: [obj.position[0], 1.0, obj.position[2] + 2], active: true, color: '#ff0000' });
                       hasChanges = true;
                       window.dispatchEvent(new CustomEvent('particle-burst', { detail: { position: obj.position, color: '#ff00ff' } }));
                   }
              }

              let keep = true;
              if (obj.active) {
                  const zThreshold = 2.0; 
                  const inZZone = (prevZ < playerPos.z + zThreshold) && (obj.position[2] > playerPos.z - zThreshold);
                  if (obj.type === ObjectType.SHOP_PORTAL) {
                      const dz = Math.abs(obj.position[2] - playerPos.z);
                      if (dz < 2) { 
                           openShop();
                           obj.active = false;
                           hasChanges = true;
                           keep = false; 
                      }
                  } else if (inZZone) {
                      const dx = Math.abs(obj.position[0] - playerPos.x);
                      if (dx < 0.9) {
                           const isDamageSource = obj.type === ObjectType.OBSTACLE || obj.type === ObjectType.ALIEN || obj.type === ObjectType.MISSILE;
                           if (isDamageSource) {
                               const playerBottom = playerPos.y;
                               const playerTop = playerPos.y + 1.8; 
                               let objBottom = obj.position[1] - 0.5;
                               let objTop = obj.position[1] + 0.5;
                               if (obj.type === ObjectType.OBSTACLE) { objBottom = 0; objTop = OBSTACLE_HEIGHT; } 
                               else if (obj.type === ObjectType.MISSILE) { objBottom = 0.5; objTop = 1.5; }
                               const isHit = (playerBottom < objTop) && (playerTop > objBottom);
                               if (isHit) { 
                                   window.dispatchEvent(new Event('player-hit'));
                                   obj.active = false; 
                                   hasChanges = true;
                                   if (obj.type === ObjectType.MISSILE) {
                                      window.dispatchEvent(new CustomEvent('particle-burst', { detail: { position: obj.position, color: '#ff4400' } }));
                                   }
                               }
                           } else {
                               const dy = Math.abs(obj.position[1] - playerPos.y);
                               if (dy < 2.5) { 
                                  if (obj.type === ObjectType.GEM) { collectGem(obj.points || 50); audio.playGemCollect(); }
                                  if (obj.type === ObjectType.LETTER && obj.targetIndex !== undefined) { collectLetter(obj.targetIndex); audio.playLetterCollect(); }
                                  window.dispatchEvent(new CustomEvent('particle-burst', { detail: { position: obj.position, color: obj.color || '#ffffff' } }));
                                  obj.active = false;
                                  hasChanges = true;
                               }
                           }
                      }
                  }
              }
              if (obj.position[2] > REMOVE_DISTANCE) { keep = false; hasChanges = true; }
              if (keep) keptObjects.push(obj);
          }
          if (newSpawns.length > 0) keptObjects.push(...newSpawns);

          let furthestZ = 0;
          const staticObjects = keptObjects.filter(o => o.type !== ObjectType.MISSILE);
          if (staticObjects.length > 0) furthestZ = Math.min(...staticObjects.map(o => o.position[2])); else furthestZ = -20;

          if (furthestZ > -SPAWN_DISTANCE) {
               const minGap = 12 + (speed * 0.4); 
               const spawnZ = Math.min(furthestZ - minGap, -SPAWN_DISTANCE);
               const isLetterDue = distanceTraveled.current >= nextLetterDistance.current;
               if (isLetterDue) {
                   const lane = getRandomLane(laneCount);
                   const target = ['G','E','M','I','N','I'];
                   const availableIndices = target.map((_, i) => i).filter(i => !collectedLetters.includes(i));
                   if (availableIndices.length > 0) {
                       const chosenIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                       const val = target[chosenIndex];
                       const color = GEMINI_COLORS[chosenIndex];
                       keptObjects.push({ id: uuidv4(), type: ObjectType.LETTER, position: [lane * LANE_WIDTH, 1.0, spawnZ], active: true, color: color, value: val, targetIndex: chosenIndex });
                       nextLetterDistance.current += getLetterInterval(level);
                       hasChanges = true;
                   } else {
                      keptObjects.push({ id: uuidv4(), type: ObjectType.GEM, position: [lane * LANE_WIDTH, 1.2, spawnZ], active: true, color: '#00ffff', points: 50 });
                      hasChanges = true;
                   }
               } else if (Math.random() > 0.1) { 
                  const isObstacle = Math.random() > 0.20;
                  if (isObstacle) {
                      const spawnAlien = level >= 2 && Math.random() < 0.2; 
                      if (spawnAlien) {
                          const availableLanes = [];
                          const maxLane = Math.floor(laneCount / 2);
                          for (let i = -maxLane; i <= maxLane; i++) availableLanes.push(i);
                          availableLanes.sort(() => Math.random() - 0.5);
                          let alienCount = 1;
                          const pAlien = Math.random();
                          if (pAlien > 0.7) alienCount = Math.min(2, availableLanes.length);
                          if (pAlien > 0.9 && availableLanes.length >= 3) alienCount = 3;
                          for (let k = 0; k < alienCount; k++) {
                              const lane = availableLanes[k];
                              keptObjects.push({ id: uuidv4(), type: ObjectType.ALIEN, position: [lane * LANE_WIDTH, 1.5, spawnZ], active: true, color: '#00ff00', hasFired: false });
                          }
                      } else {
                          const availableLanes = [];
                          const maxLane = Math.floor(laneCount / 2);
                          for (let i = -maxLane; i <= maxLane; i++) availableLanes.push(i);
                          availableLanes.sort(() => Math.random() - 0.5);
                          let countToSpawn = 1;
                          const p = Math.random();
                          if (p > 0.80) countToSpawn = Math.min(3, availableLanes.length); else if (p > 0.50) countToSpawn = Math.min(2, availableLanes.length); else countToSpawn = 1;
                          for (let i = 0; i < countToSpawn; i++) {
                              const lane = availableLanes[i];
                              const laneX = lane * LANE_WIDTH;
                              keptObjects.push({ id: uuidv4(), type: ObjectType.OBSTACLE, position: [laneX, OBSTACLE_HEIGHT / 2, spawnZ], active: true, color: '#ff0054' });
                              if (Math.random() < 0.3) {
                                   keptObjects.push({ id: uuidv4(), type: ObjectType.GEM, position: [laneX, OBSTACLE_HEIGHT + 1.0, spawnZ], active: true, color: '#ffd700', points: 100 });
                              }
                          }
                      }
                  } else {
                      const lane = getRandomLane(laneCount);
                      keptObjects.push({ id: uuidv4(), type: ObjectType.GEM, position: [lane * LANE_WIDTH, 1.2, spawnZ], active: true, color: '#00ffff', points: 50 });
                  }
                  hasChanges = true;
               }
          }
          if (hasChanges) {
              objectsRef.current = keptObjects;
              setRenderTrigger(t => t + 1);
          }
        });

        return (
          <group>
            <ParticleSystem />
            {objectsRef.current.map(obj => {
              if (!obj.active) return null;
              return <GameEntity key={obj.id} data={obj} />;
            })}
          </group>
        );
      };

      // --- HUD ---
      const SHOP_ITEMS = [
          { id: 'DOUBLE_JUMP', name: 'DOUBLE JUMP', description: 'Jump again in mid-air. Essential for high obstacles.', cost: 1000, icon: ArrowUpCircle, oneTime: true },
          { id: 'MAX_LIFE', name: 'MAX LIFE UP', description: 'Permanently adds a heart slot and heals you.', cost: 1500, icon: Activity },
          { id: 'HEAL', name: 'REPAIR KIT', description: 'Restores 1 Life point instantly.', cost: 1000, icon: PlusCircle },
          { id: 'IMMORTAL', name: 'IMMORTALITY', description: 'Unlock Ability: Press Space/Tap to be invincible for 5s.', cost: 3000, icon: Shield, oneTime: true }
      ];

      const ShopScreen = () => {
          const { score, buyItem, closeShop, hasDoubleJump, hasImmortality } = useStore();
          const [items, setItems] = useState([]);
          useEffect(() => {
              let pool = SHOP_ITEMS.filter(item => {
                  if (item.id === 'DOUBLE_JUMP' && hasDoubleJump) return false;
                  if (item.id === 'IMMORTAL' && hasImmortality) return false;
                  return true;
              });
              pool = pool.sort(() => 0.5 - Math.random());
              setItems(pool.slice(0, 3));
          }, []);

          return (
              <div className="absolute inset-0 bg-black/90 z-[100] text-white pointer-events-auto backdrop-blur-md overflow-y-auto">
                   <div className="flex flex-col items-center justify-center min-h-full py-8 px-4">
                       <h2 className="text-3xl md:text-4xl font-black text-cyan-400 mb-2 font-cyber tracking-widest text-center">CYBER SHOP</h2>
                       <div className="flex items-center text-yellow-400 mb-6 md:mb-8">
                           <span className="text-base md:text-lg mr-2">AVAILABLE CREDITS:</span>
                           <span className="text-xl md:text-2xl font-bold">{score.toLocaleString()}</span>
                       </div>
                       <div className="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6 max-w-4xl w-full mb-8">
                           {items.map(item => {
                               const Icon = item.icon;
                               const canAfford = score >= item.cost;
                               return (
                                   <div key={item.id} className="bg-gray-900/80 border border-gray-700 p-4 md:p-6 rounded-xl flex flex-col items-center text-center hover:border-cyan-500 transition-colors">
                                       <div className="bg-gray-800 p-3 md:p-4 rounded-full mb-3 md:mb-4">
                                           <Icon className="w-6 h-6 md:w-8 md:h-8 text-cyan-400" />
                                       </div>
                                       <h3 className="text-lg md:text-xl font-bold mb-2">{item.name}</h3>
                                       <p className="text-gray-400 text-xs md:text-sm mb-4 h-10 md:h-12 flex items-center justify-center">{item.description}</p>
                                       <button 
                                          onClick={() => buyItem(item.id, item.cost)}
                                          disabled={!canAfford}
                                          className={`px-4 md:px-6 py-2 rounded font-bold w-full text-sm md:text-base ${canAfford ? 'bg-gradient-to-r from-cyan-600 to-blue-600 hover:brightness-110' : 'bg-gray-700 cursor-not-allowed opacity-50'}`}
                                       >
                                           {item.cost} GEMS
                                       </button>
                                   </div>
                               );
                           })}
                       </div>
                       <button onClick={closeShop} className="flex items-center px-8 md:px-10 py-3 md:py-4 bg-gradient-to-r from-purple-600 to-pink-600 text-white font-bold text-lg md:text-xl rounded hover:scale-105 transition-all shadow-[0_0_20px_rgba(255,0,255,0.4)]">
                           RESUME MISSION <Play className="ml-2 w-5 h-5" fill="white" />
                       </button>
                   </div>
              </div>
          );
      };

      const HUD = () => {
        const { score, lives, maxLives, collectedLetters, status, level, restartGame, startGame, gemsCollected, distance, isImmortalityActive, speed } = useStore();
        const target = ['G', 'E', 'M', 'I', 'N', 'I'];
        const containerClass = "absolute inset-0 pointer-events-none flex flex-col justify-between p-4 md:p-8 z-50";

        if (status === GameStatus.SHOP) return <ShopScreen />;
        if (status === GameStatus.MENU) {
            return (
                <div className="absolute inset-0 flex items-center justify-center z-[100] bg-black/80 backdrop-blur-sm p-4 pointer-events-auto">
                    <div className="relative w-full max-w-md rounded-3xl overflow-hidden shadow-[0_0_50px_rgba(0,255,255,0.2)] border border-white/10 animate-in zoom-in-95 duration-500">
                      <div className="relative w-full bg-gray-900">
                           <img src="https://www.gstatic.com/aistudio/starter-apps/gemini_runner/gemini_runner.png" alt="Gemini Runner Cover" className="w-full h-auto block" />
                           <div className="absolute inset-0 bg-gradient-to-t from-[#050011] via-black/30 to-transparent"></div>
                           <div className="absolute inset-0 flex flex-col justify-end items-center p-6 pb-8 text-center z-10">
                              <button 
                                onClick={() => { audio.init(); startGame(); }}
                                className="w-full group relative px-6 py-4 bg-white/10 backdrop-blur-md border border-white/20 text-white font-black text-xl rounded-xl hover:bg-white/20 transition-all shadow-[0_0_20px_rgba(0,255,255,0.2)] hover:shadow-[0_0_30px_rgba(0,255,255,0.4)] hover:border-cyan-400 overflow-hidden"
                              >
                                  <div className="absolute inset-0 bg-gradient-to-r from-cyan-500/40 via-purple-500/40 to-pink-500/40 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700"></div>
                                  <span className="relative z-10 tracking-widest flex items-center justify-center">
                                      INITIALIZE RUN <Play className="ml-2 w-5 h-5 fill-white" />
                                  </span>
                              </button>
                              <p className="text-cyan-400/60 text-[10px] md:text-xs font-mono mt-3 tracking-wider">[ ARROWS / SWIPE TO MOVE ]</p>
                           </div>
                      </div>
                    </div>
                </div>
            );
        }
        if (status === GameStatus.GAME_OVER) {
            return (
                <div className="absolute inset-0 bg-black/90 z-[100] text-white pointer-events-auto backdrop-blur-sm overflow-y-auto">
                    <div className="flex flex-col items-center justify-center min-h-full py-8 px-4">
                      <h1 className="text-4xl md:text-6xl font-black text-white mb-6 drop-shadow-[0_0_10px_rgba(255,0,0,0.8)] font-cyber text-center">GAME OVER</h1>
                      <div className="grid grid-cols-1 gap-3 md:gap-4 text-center mb-8 w-full max-w-md">
                          <div className="bg-gray-900/80 p-3 md:p-4 rounded-lg border border-gray-700 flex items-center justify-between">
                              <div className="flex items-center text-yellow-400 text-sm md:text-base"><Trophy className="mr-2 w-4 h-4 md:w-5 md:h-5"/> LEVEL</div>
                              <div className="text-xl md:text-2xl font-bold font-mono">{level} / 3</div>
                          </div>
                          <div className="bg-gray-900/80 p-3 md:p-4 rounded-lg border border-gray-700 flex items-center justify-between">
                              <div className="flex items-center text-cyan-400 text-sm md:text-base"><Diamond className="mr-2 w-4 h-4 md:w-5 md:h-5"/> GEMS COLLECTED</div>
                              <div className="text-xl md:text-2xl font-bold font-mono">{gemsCollected}</div>
                          </div>
                          <div className="bg-gray-900/80 p-3 md:p-4 rounded-lg border border-gray-700 flex items-center justify-between">
                              <div className="flex items-center text-purple-400 text-sm md:text-base"><MapPin className="mr-2 w-4 h-4 md:w-5 md:h-5"/> DISTANCE</div>
                              <div className="text-xl md:text-2xl font-bold font-mono">{Math.floor(distance)} LY</div>
                          </div>
                           <div className="bg-gray-800/50 p-3 md:p-4 rounded-lg flex items-center justify-between mt-2">
                              <div className="flex items-center text-white text-sm md:text-base">TOTAL SCORE</div>
                              <div className="text-2xl md:text-3xl font-bold font-cyber text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500">{score.toLocaleString()}</div>
                          </div>
                      </div>
                      <button onClick={() => { audio.init(); restartGame(); }} className="px-8 md:px-10 py-3 md:py-4 bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-bold text-lg md:text-xl rounded hover:scale-105 transition-all shadow-[0_0_20px_rgba(0,255,255,0.4)]">RUN AGAIN</button>
                    </div>
                </div>
            );
        }
        if (status === GameStatus.VICTORY) {
          return (
              <div className="absolute inset-0 bg-gradient-to-b from-purple-900/90 to-black/95 z-[100] text-white pointer-events-auto backdrop-blur-md overflow-y-auto">
                  <div className="flex flex-col items-center justify-center min-h-full py-8 px-4">
                      <Rocket className="w-16 h-16 md:w-24 md:h-24 text-yellow-400 mb-4 animate-bounce drop-shadow-[0_0_15px_rgba(255,215,0,0.6)]" />
                      <h1 className="text-3xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 via-orange-500 to-pink-500 mb-2 drop-shadow-[0_0_20px_rgba(255,165,0,0.6)] font-cyber text-center leading-tight">MISSION COMPLETE</h1>
                      <p className="text-cyan-300 text-sm md:text-2xl font-mono mb-8 tracking-widest text-center">THE ANSWER TO THE UNIVERSE HAS BEEN FOUND</p>
                      <div className="grid grid-cols-1 gap-4 text-center mb-8 w-full max-w-md">
                          <div className="bg-black/60 p-6 rounded-xl border border-yellow-500/30 shadow-[0_0_15px_rgba(255,215,0,0.1)]">
                              <div className="text-xs md:text-sm text-gray-400 mb-1 tracking-wider">FINAL SCORE</div>
                              <div className="text-3xl md:text-4xl font-bold font-cyber text-yellow-400">{score.toLocaleString()}</div>
                          </div>
                           <div className="grid grid-cols-2 gap-4">
                              <div className="bg-black/60 p-4 rounded-lg border border-white/10">
                                  <div className="text-xs text-gray-400">GEMS</div>
                                  <div className="text-xl md:text-2xl font-bold text-cyan-400">{gemsCollected}</div>
                              </div>
                              <div className="bg-black/60 p-4 rounded-lg border border-white/10">
                                   <div className="text-xs text-gray-400">DISTANCE</div>
                                  <div className="text-xl md:text-2xl font-bold text-purple-400">{Math.floor(distance)} LY</div>
                              </div>
                           </div>
                      </div>
                      <button onClick={() => { audio.init(); restartGame(); }} className="px-8 md:px-12 py-4 md:py-5 bg-white text-black font-black text-lg md:text-xl rounded hover:scale-105 transition-all shadow-[0_0_40px_rgba(255,255,255,0.3)] tracking-widest">RESTART MISSION</button>
                  </div>
              </div>
          );
        }
        return (
          <div className={containerClass}>
              <div className="flex justify-between items-start w-full">
                  <div className="flex flex-col">
                      <div className="text-3xl md:text-5xl font-bold text-cyan-400 drop-shadow-[0_0_10px_#00ffff] font-cyber">{score.toLocaleString()}</div>
                  </div>
                  <div className="flex space-x-1 md:space-x-2">
                      {[...Array(maxLives)].map((_, i) => (
                          <Heart key={i} className={`w-6 h-6 md:w-8 md:h-8 ${i < lives ? 'text-pink-500 fill-pink-500' : 'text-gray-800 fill-gray-800'} drop-shadow-[0_0_5px_#ff0054]`} />
                      ))}
                  </div>
              </div>
              <div className="absolute top-5 left-1/2 transform -translate-x-1/2 text-sm md:text-lg text-purple-300 font-bold tracking-wider font-mono bg-black/50 px-3 py-1 rounded-full border border-purple-500/30 backdrop-blur-sm z-50">LEVEL {level} <span className="text-gray-500 text-xs md:text-sm">/ 3</span></div>
              {isImmortalityActive && (
                   <div className="absolute top-24 left-1/2 transform -translate-x-1/2 text-yellow-400 font-bold text-xl md:text-2xl animate-pulse flex items-center drop-shadow-[0_0_10px_gold]">
                       <Shield className="mr-2 fill-yellow-400" /> IMMORTAL
                   </div>
              )}
              <div className="absolute top-16 md:top-24 left-1/2 transform -translate-x-1/2 flex space-x-2 md:space-x-3">
                  {target.map((char, idx) => {
                      const isCollected = collectedLetters.includes(idx);
                      const color = GEMINI_COLORS[idx];
                      return (
                          <div key={idx} style={{ borderColor: isCollected ? color : 'rgba(55, 65, 81, 1)', color: isCollected ? 'rgba(0, 0, 0, 0.8)' : 'rgba(55, 65, 81, 1)', boxShadow: isCollected ? `0 0 20px ${color}` : 'none', backgroundColor: isCollected ? color : 'rgba(0, 0, 0, 0.9)' }} className={`w-8 h-10 md:w-10 md:h-12 flex items-center justify-center border-2 font-black text-lg md:text-xl font-cyber rounded-lg transform transition-all duration-300`}>{char}</div>
                      );
                  })}
              </div>
              <div className="w-full flex justify-end items-end">
                   <div className="flex items-center space-x-2 text-cyan-500 opacity-70">
                       <Zap className="w-4 h-4 md:w-6 md:h-6 animate-pulse" />
                       <span className="font-mono text-base md:text-xl">SPEED {Math.round((speed / RUN_SPEED_BASE) * 100)}%</span>
                   </div>
              </div>
          </div>
        );
      };

      // --- APP ---
      const CameraController = () => {
        const { camera, size } = useThree();
        const { laneCount } = useStore();
        useFrame((state, delta) => {
          const aspect = size.width / size.height;
          const isMobile = aspect < 1.2; 
          const heightFactor = isMobile ? 2.0 : 0.5;
          const distFactor = isMobile ? 4.5 : 1.0;
          const extraLanes = Math.max(0, laneCount - 3);
          const targetY = 5.5 + (extraLanes * heightFactor);
          const targetZ = 8.0 + (extraLanes * distFactor);
          const targetPos = new THREE.Vector3(0, targetY, targetZ);
          camera.position.lerp(targetPos, delta * 2.0);
          camera.lookAt(0, 0, -30); 
        });
        return null;
      };

      function Scene() {
        return (
          <>
              <Environment />
              <group>
                  <group userData={{ isPlayer: true }} name="PlayerGroup">
                       <Player />
                  </group>
                  <LevelManager />
              </group>
              <Effects />
          </>
        );
      }

      function App() {
        return (
          <div className="relative w-full h-screen bg-black overflow-hidden select-none">
            <HUD />
            <Canvas shadows dpr={[1, 1.5]} gl={{ antialias: false, stencil: false, depth: true, powerPreference: "high-performance" }} camera={{ position: [0, 5.5, 8], fov: 60 }}>
              <CameraController />
              <Suspense fallback={null}>
                  <Scene />
              </Suspense>
            </Canvas>
          </div>
        );
      }

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>